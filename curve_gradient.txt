https://mackoy.exblog.jp/23325011/

構文の数がかなり増えていますが、これは複数通りの記述方法を設けたためで、すべての構文を使用する必要はありません。
以下の記述はすべて同じ意味になります。
Gradient も同様です。

従来の記述方法
100; Curve.BeginTransition();		Track['foo'].Cant(0);
200; Curve.BeginCircular(600, 0.1);	Track['foo'].Cant(0.1);
300; Curve.BeginTransition();		Track['foo'].Cant(0.1);
400; Curve.End();			Track['foo'].Cant(0);
1000; Curve.BeginCircular(200, 0);
1020; Curve.End();

新しい記述方法 1
100; Curve.BeginTransition();		Track['foo'].Cant.BeginTransition();
200; Curve.Begin(600, 0.1);		Track['foo'].Cant.Begin(0.1);
300; Curve.BeginTransition();		Track['foo'].Cant.BeginTransition();
400; Curve.End();			Track['foo'].Cant.End();
1000; Curve.Begin(200);
1020; Curve.End();

新しい記述方法 2
100; Curve.Interpolate();		Track['foo'].Cant.Interpolate();
200; Curve.Interpolate(600, 0.1);	Track['foo'].Cant.Interpolate(0.1);
300; Curve.Interpolate();		Track['foo'].Cant.Interpolate();
400; Curve.Interpolate(0, 0);		Track['foo'].Cant.Interpolate(0);
1000; Curve.Change(200);
1020; Curve.Change(0);

--------

こういう対応関係か？
BeginTransition() = Interpolate()
BeginCircular(hoge, fuga) = Begin(hoge, fuga) = Interpolate(hoge, fuga)
End() = Interpolate(0,0)

↑は微妙に違う。
Beginは緩和曲線・縦曲線を指定しない場合に使う。
↑も間違い。新しい記述方法1と矛盾する。

Interpolateは一つ前のInterpolate or changeで指定した点から現時点までを補間する。

begintransitionなしにbegin構文を連続して指定した場合、begin同士の間は補間されるかどうか？
されない場合は条件に応じてchange/interpolateいずれかの振る舞いに変化することになる。

end, changeをbeginで置き換えるような簡略化を下手に行わない。putdataのtypeで区別できるようにする。
インタプリタの時点ではcant, gradient, radiusのような場合分けを行わないで、読み込んだ順番にリストを作成する。
古いBASICの中間コードのイメージ。

構文解析を全ファイル一括から一行ごとに切り替えたので、構文解析と同時に最終処理（自軌道のxy座標算出、縦断面図作成）が可能かも？
↑距離程のソートができなくなるのでやめたほうがいい。構文解析時は中間コードへの変換のみ行い、全て読み込み終了してから距離程でソートののち最終処理。